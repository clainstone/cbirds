#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#include "boids.h"

const int PERCEPTION_RADIUS;
const int TURN_RADIUS;
const double SEPARATION_WEIGHT = 0.01;
const double ALIGNMENT_WEIGHT = 0.01;
const double COHESION_WEIGHT = 0.01;
const double BOUNDARY_AV_WEIGHT = 5.0;

typedef struct {
    int x, y, id, width, heigth, speed;
double direction} bird_t;

typedef struct {
    int x, y;
} vector2d_t;
bird_t *init_bird(int id, int speed, int width, int heigth,
                  int screen_width, int screen_heigth);

void update_birds(bird_t ** birds, int screen_width, int screen_height,
                  int num_birds);

static void update_direction(bird_t * bird, double next_direction);
static double calculate_rules_direction(bird_t * bird, bird_t ** birds,
                                        int num_birds,
                                        double separation_weight,
                                        double alignment_weight,
                                        double cohesion_weight,
                                        double boundary_av_weight,
                                        int screen_width,
                                        int screen_heigth,
                                        int turn_radius);
static vector2d_t *calculate_boundary_av_direction(bird_t * bird,
                                                   int screen_width,
                                                   int screen_heigth,
                                                   int turn_radius);
static void add_vector(vector2d_t * vector, int x, int y);
static void prod_vector(vector2d_t * vector, double scalar);
static int distance(bird_t * b1, bird_t * b2);
static bird_t **close_birds(bird_t * target, bird_t ** birds,
                            int num_birds, int perception_radius,
                            int *counter);



static void update_direction(bird_t *bird, double next_direction)
{
    bird->direction = next_direction;
    bird->x += bird->speed * cos(next_direction);
    bird->y += bird->speed * sin(next_direction);
}

/**
 * @brief Initializes a bird with random position and direction.
 * The returned bird is dynamically allocated and should be freed by the caller.
 */
bird_t *init_bird(int id, int speed, int width, int heigth,
                  int screen_width, int screen_heigth)
{
    srand(time(NULL));
    bird_t *bird = (bird_t *) malloc(sizeof(bird_t));

    bird->x = screen_width * (rand() / RAND_MAX);
    bird->y = screen_heigth * (rand() / RAND_MAX);
    bird->direction = 2 * M_PI * (rand() / RAND_MAX);
    bird->id = id;
    bird->speed = speed;
    bird->width = width;
    bird->heigth = heigth;
}

static void init_vector(vector2d_t *vector, int x, int y)
{
    vector->x = x;
    vector->y = y;
}

static void add_vector(vector2d_t *vector, int x, int y)
{
    vector->x += x;
    vector->y += y;
}

static void prod_vector(vector2d_t *vector, double scalar)
{
    vector->x *= scalar;
    vector->y *= scalar;
}

/**
 * The returned vector is dynamically allocated and should be freed by the caller.
 */
static vector2d_t *calculate_boundary_av_direction(bird_t *bird,
                                                   int screen_width,
                                                   int screen_heigth,
                                                   int turn_radius)
{
    vector2d_t *boundary_av = (vector2d_t *) malloc(sizeof(vector2d_t));

    init_vector(boundary_av, 0, 0);

    if (bird->x < turn_radius) {
        add_vector(boundary_av, 1, 0);
    } else if (bird->x > screen_width - turn_radius) {
        add_vector(boundary_av, -1, 0);
    }
    if (bird->y < turn_radius) {
        add_vector(boundary_av, 0, 1);
    } else if (bird->y > screen_heigth - turn_radius) {
        add_vector(boundary_av, 0, -1);
    }
    return boundary_av;
}


static double
calculate_rules_direction(bird_t *target, bird_t **birds,
                          int num_birds,
                          double separation_weight,
                          double alignment_weight,
                          double cohesion_weight,
                          double boundary_av_weight,
                          int screen_width,
                          int screen_heigth, int turn_radius)
{
    vector2d_t separation = { 0, 0 };
    vector2d_t alignment = { 0, 0 };
    vector2d_t cohesion = { 0, 0 };

    vector2d_t *boundary_av_ptr =
        calculate_boundary_av_direction(target, screen_width,
                                        screen_heigth, turn_radius);

    int close_count = 0;

    for (int i = 0; i < num_birds; i++) {
        bird_t boid = *birds[i];

        if (boid.id != target->id) {
            add_vector(&separation, target->x - boid.x,
                       target->y - boid.y);
            add_vector(&alignment, cos(boid.direction),
                       sin(boid.direction));
            add_vector(&cohesion, boid.x, boid.y);
            close_count++;
        }
    }

    if (close_count > 0) {

        alignment.x /= close_count;
        alignment.y /= close_count;
        cohesion.x /= close_count;
        cohesion.y /= close_count;

        cohesion.x -= target->x;
        cohesion.y -= target->y;

        prod_vector(&separation, separation_weight);
        prod_vector(&alignment, alignment_weight);
        prod_vector(&cohesion, cohesion_weight);
        prod_vector(boundary_av_ptr, boundary_av_weight);

        double result_x =
            separation.x + alignment.x + cohesion.x + boundary_av_ptr->x;
        double result_y =
            separation.y + alignment.y + cohesion.y + boundary_av_ptr->y;
        free(boundary_av_ptr);

        return atan2(result_y, result_x);
    } else {
        free(boundary_av_ptr);
        return target->direction;
    }
}

static int distance(bird_t *b1, bird_t *b2)
{
    return sqrt((b1->x - b2->x) * (b1->x - b2->x) +
                (b1->y - b2->y) * (b1->y - b2->y));
}

/**
 * @brief Returns an array of birds that are within the perception radius of the target bird.
 * The returned array is dynamically allocated and should be freed by the caller.
 * If no birds are found within the perception radius, or if an error arises, NULL is returned.
 */
static bird_t **close_birds(bird_t *target, bird_t **birds, int num_birds,
                            int perception_radius, int *counter)
{
    bird_t **close_birds = (bird_t *) malloc(num_birds * sizeof(bird_t));

    for (int i = 0; i < num_birds; i++) {
        bird_t *boid = birds[i];

        if (boid->id != target->id) {
            if (distance(target, boid) < perception_radius) {
                close_birds[*counter] = boid;
                *counter++;
            }
        }
    }

    if (*counter == 0) {
        free(close_birds);
        return NULL;
    } else if (*counter <= num_birds) {
        bird_t *resized_close_birds = (bird_t *) realloc(close_birds,
                                                         *counter *
                                                         sizeof(bird_t));
        if (resized_close_birds != NULL) {
            close_birds = resized_close_birds;
            return close_birds;
        } else {
            perror("Realloc failed");
            return NULL;
        }
    }
}

void update_birds(bird_t **birds, int screen_width, int screen_height,
                  int num_birds)
{
    for (int i = 0; i < num_birds; i++) {
        int counter = 0;
        bird_t **close = close_birds(birds[i], birds, num_birds,
                                     PERCEPTION_RADIUS,
                                     &counter);

        if (counter > 0) {
            double direction = calculate_rules_direction(birds[i], close,
                                                         counter,
                                                         SEPARATION_WEIGHT,
                                                         ALIGNMENT_WEIGHT,
                                                         COHESION_WEIGHT,
                                                         BOUNDARY_AV_WEIGHT,
                                                         screen_width,
                                                         screen_height,
                                                         TURN_RADIUS);
            update_direction(birds[i], direction);
        }

    }
}
